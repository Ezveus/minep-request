#!/usr/bin/env ruby

lib = "/home/matthieu/Documents/Proj/Ruby/WEBSocket/lib"
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'optparse'
require 'json'
require 'celluloid/io'
require 'uri'
require 'websocket'
require 'WEBSocket'

$options = {
  :host => "localhost",
  :port => 8080,
  :type => :tcp
}
$goon = true
$commands = {
  "authenticate" => [ Proc.new { |s| authenticate s},
                      "Send an AUTHENTICATE request" ],
  "signup" => [ Proc.new { |s| signup s},
                "Send a SIGNUP request" ],
  "exec" => [ Proc.new { |s| exec s},
              "Send an EXEC request" ],
  "insert" => [ Proc.new { |s| insert s},
                "Send an INSERT request" ],
  "move" => [ Proc.new { |s| move s},
              "Send a MOVE request" ],
  "backspace" => [ Proc.new { |s| backspace s},
                   "Send a BACKSPACE request" ],
  "delete" => [ Proc.new { |s| delete s},
                "Send a DELETE request" ],
  "help" => [ Proc.new { |s| help s},
              "Show the list of the commands" ],
  "exit" => [ Proc.new { |s| quit s},
              "Disconnect and quit the program" ],
  "quit" => [ Proc.new { |s| quit s},
              "Disconnect and quit the program" ]
}

def read
  input = $stdin.readline
  input = input.strip
end

def makeMsg request, args
  args.each_key do |k|
    if k == :args
      printf "#{k} as a space-separated list : "
      input = read
      args[k] = input.split
    elsif k == :direction
      printf "#{k} (up, right, down, left, origin, end) : "
      args[k] = read
    elsif k == :number
      printf "#{k} : "
      args[k] = read.to_i
    else
      printf "#{k} : "
      args[k] = read
    end
  end
  "#{request.upcase}=#{JSON.dump args}"
end

def file socket
  args = {
    :path => "",
    :size => 0,
    :line => 0,
    :port => 0
  }
  printf "path : "
  args[:path] = read
  printf "line number : "
  args[:line] = read.to_i
  if File.exist? args[:path]
    f = File.new args[:path]
    args[:size] = f.size
    args[:content] = f.read
    socket.write "FILE=#{JSON.dump args}"
  else
    $stderr.puts "File #{args[:path]} doesn't exists"
  end
end

def authenticate socket
  args = {
    :name => "",
    :pass => ""
  }
  socket.write makeMsg("AUTHENTICATE", args)
end

def signup socket
  args = {
    :name => "",
    :pass => "",
    :email => "",
    :website => ""
  }
  socket.write makeMsg("SIGNUP", args)
end

def exec socket
  args = {
    :buffer => "",
    :command => "",
    :args => []
  }
  socket.write makeMsg("EXEC", args)
end

def insert socket
  args = {
    :buffer => "",
    :text => ""
  }
  socket.write makeMsg("INSERT", args)
end

def move socket
  args = {
    :buffer => "",
    :direction => "",
    :number => 0
  }
  socket.write makeMsg("MOVE", args)
end

def backspace socket
  args = {
    :buffer => "",
    :number => 0
  }
  socket.write makeMsg("BACKSPACE", args)
end

def delete socket
  args = {
    :buffer => "",
    :number => 0
  }
  socket.write makeMsg("DELETE", args)
end

def quit socket = nil
  $goon = false
  puts "Exiting"
end

def help socket = nil
  puts "Valid commands are :"
  $commands.keys.sort.each do |c|
    puts "#{c} : #{$commands[c][1]}"
  end
end

optparse = OptionParser.new do |opts|
  portSpecified = false
  opts.banner = <<-eos
Usage: mine-request [OPTIONS]
Send a request to a MINE server
eos

  opts.on "-h", "--host HOST", "server hostname" do |h|
    $options[:host] = h
  end

  opts.on "-p", "--port PORT", Integer, "server port" do |p|
    $options[:port] = p
    portSpecified = true
  end

  opts.on "-t", "--type TYPE", [:tcp, :websocket], "type of communication (tcp | websocket)" do |t|
    $options[:type] = t
    $options[:port] = 8081 unless portSpecified
  end

  opts.on "--help", "displays this screen" do |h|
    puts opts
    exit 1
  end
end

begin
  optparse.parse!
rescue OptionParser::InvalidOption, OptionParser::MissingArgument, OptionParser::InvalidArgument
  puts $!.to_s
  puts optparse
  exit 1
end

puts "[Debug] Options : #{$options}"

if $options[:type] == :tcp
  socket = Celluloid::IO::TCPSocket.new $options[:host], $options[:port]
elsif $options[:type] == :websocket
  socket = WEBSocket::Socket.new $options[:host], $options[:port]
end

while $goon do
  printf ">> "
  begin
    cmd = read
    if $commands.key? cmd
      $commands[cmd][0].call socket
    else
      $stderr.puts "Error : unknown command"
    end
  rescue EOFError
    quit
  end
end
